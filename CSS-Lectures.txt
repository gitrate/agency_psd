/* ******************************************
27_lesson_css_13
медиа-запросы / media query */

/* медиа-запрос
записывают в CSS-файле, запись начинается с @media (без пробелов), эта запись указывает на то, что сейчас пойдёт тело запроса */

/* тип носителя
дальше, через пробел указывается тип носителя - всего их четыре вида, и ноль или более характеристик носителя

			media types

	all				все устройства
	
	print			для постраничного просмотра материала и документов, просматриваемых на
						экране в режиме предварительного просмотра перед печатью.
						
	screen		компьютеры, телефоны и т.п.
	
	speech		устройства для синтеза речи
  */

	/* логические операторы
	обычно используют всего два ("and" - "и", "или" - ","(запятая)) из четырёх (и, или, только, не) ("только" - "only" (нет смысла выделять какое-то конкретное устройство, обычно указывают media types -  screen, и этого достаточно), "не" - "not")
	*/
	
/* характеристики медиа-запроса
(ширина, высота, aspect-ratio - (16:9, 16:10, 3:4), orientation - portrait, landscape, плотность набивки пикселей, монохромные устройства ... ). Основной характеристикой является ширина, поскольку редко когда требуется ограничение по высоте устройства, ограничивая ширину, мы "выдавливаем" контент вниз:

@media screen and (min-width: 640px) and (max-width: 1024px)

если с характеристиками медиа-запроса разобрались, то открываем фигурные скобки,
пишем, как в CSS, селектор, к которому хотим применить правило

@media screen and (min-width: 640px) and (max-width: 1024px) {
	 h1 {
		 font-size: 18px;
	 }
	 .sidebar {
		 background: #dadada;
	 }
}
*/

/* Принцип mobile-first подразумевает, что мобильному устройству нужно как можно быстрее отрендерить страницу, а для этого качать как можно меньше CSS-правил. Обычно записывается стандартный CSS, а ниже идут медиа-запросы, которые меняют поведение элементов, указанных в медиа-запросе на той ширине (диапазоне), которая указана в медиа-запросе (для бОльших мониторов, на быстрых каналах связи). При такой записи, мобильное устройство не будет трогать/видеть медиа-запрос (но файл-то всё равно скачает полностью)
Медиа-запросы в обычных случаях обладают более высоким приоритетом. Поскольку подчиняются стандартной каскадности, именно из-за этого медиа-запросы записываются внизу CSS-файла, чтобы они могли перебить наши основные стили. Медиа-запросы с max-width перебивают друг друга, если записаны от меньшего размера к большему, с min-width картина обратная - сначала пишут правила для наибольших размеров, а потом идут правила со всё меньшими размерами экрана.
Если дизайн не мобайл-фёрст, то при уменьшении размера экрана мы ловим момент, когда вёрстка начинает ломаться и пишем для этого разрешения медиа-запрос.
При выборе подхода к вёрстке, необходимо стремиться к уменьшению количества правил и медиа-запросов, чтобы ускорить загрузку.
На андроидах - хромах и мозиллах - там, обычно, всё в порядке. В мобильных сафари, обычно, те же грабли, что и в десктопных сафари. Проверять респонсив на сафари лучше на самих девайсах, т.к., процентов 50 того, что вылезет на устройстве, эмулятор не отловит. Эксплореров на моб.устр. нет, но есть Эдж, который более-менее ОК.
Мастхэв - проверка в хроме и мозилле (отличия в vertical-align - в хроме все строчные элементы пытаются стать по-центру, а в мозилле - по-верху), поэтому в ресетах нужно всем строчным и строчно-блочным элементам вести себя одинаково, vertical-align: middle, например.
*/

/*
*********************************************************************************
Остановка на тайминге 0:23:00
*********************************************************************************
*/


/* ******************************************
28_lesson_css_14
FOUNDATION (база, основа)
*/

/* выбор ширины контентной области */

/*
стандартный отступ между колонками - 
15px + 15px = 30px; по краям - 15px.
*/

/*
Необходимо взвешенно подходить к выбору, использовать фреймворк или нет, а если использовать, то грузить только необходимые компоненты.
100% : 12 колонок = 8,33% - ширина одной колонки при  стандартной верстке в 12 колонок.
*/

/* диапазон ширины экрана, в которых работают классы:

class="small" - 639px и меньше
class="medium" - от 640px до 1023px
class="large" - от 1024px и до бесконечности
*/

/* принцип mobile first - 
задаётся класс small, и если его не "остановить", то при увеличении экрана (при выходе за границы действия класса small - 639px) количество колонок, заданных классом small, будет сохраняться до бесконечности;
класс medium "перебивает" действие класса small и может установить своё кол-во колонок в диапазоне от 640px до 1023px/(или до бесконечности, если класс medium не перебит классом large);
класс large "перебивает" действие классов medium и small и может установить своё кол-во колонок в диапазоне от 1024px и до бесконечности.
*/

/* <div class="row"> <!-- row - ряд - обязательный контейнер для колонок column/columns (column = columns) -->
	<div class="small-1 column"></div> <!-- одна колонка во всех диапазонах, обязательно указывать класс column -->
</div>

<div class="row">
	<div class="small-1 medium-2 column"></div> <!-- одна колонка до 639px и две от 640px до бесконечности -->
</div>

<div class="row">
	<div class="small-1 medium-2 large-4 column"></div> <!-- одна колонка до 639px, две от 640px до 1023px и четыре колонки от 1024px до бесконечности -->
</div>
*/

/* Если в html-коде foundation в файле html задать класс medium и не указать класс small, то при уменьшении ширины экрана менее 640px, все блоки станут один под другим и станут как small-12 (на всю ширину экрана)
Чтобы избежать такого поведения блоков при уменьшении экрана и оставить поведение блоков таким же как в medium, нужно дописать в блоках классы small с теми же параметрами, что у medium.
А это значит, что если мы не хотим, чтобы поведение блоков менялось при любой ширине экрана, нам достаточно задавать только класс small. 
*/

/* Нам никто не запрещает писать свои медиа-запросы. К примеру, мы хотим получить определённое поведение элементов страницы на разрешении от 1200px до 1500px - пишем:

@media screen and (min-width: 1200px) and (max-width: 1500px) {
	 h1 {
		 font-size: 18px;
	 }
	 .sidebar {
		 background: #dadada;
	 }
}
*/

/* Можно использовать правило флоатов, которому подчиняются колонки в фреймворке, и написать, к примеру, small-6, small-6, small-12; small-12 перенесётся на новую строку. */

/* foundation.zurb.com */

/* Все размеры считаются в REM'ах. Total gutter = 1,875rem; 1,875 * 16 = 30px - общее расстояние между двух колонок. По обеим сторонам колонки имеем padding 30px/2 = 15px */

/* max-width = 62,5rem = 62,5 * 16 = 1000px - ширина контентной части по умолчанию
1000/16 = max-width 62,5 rem
16px - к примеру, высота шрифта по умолчанию */

/* Настройки по-умолчанию можно менять под свои нужды. */

/* Essential - облегчённый вариант без JS-элементов, которые написаны на jQuery */

/* app.css - сюда пишут свои стили;
foundation.min.css - сжатые стили фреймворка, которые нужны для работы приложения, весит меньше, чем foundation.css;
foundation.css - классически отформатированный файл стилей, который позволяет кодерам покопаться в коде, понять, что и как работает, для сайта не нужен. */

/* После скачивания Foundation, мы имеем две папки - css и img, и файл index.html в корне проекта.

В index.html в header мы видим строки

    <link rel="stylesheet" href="css/foundation.css">
    <link rel="stylesheet" href="css/app.css">
	Логика такого расположения в том, чтобы кастомные стили перебили стандартный стиль foundation, перебивать стандартные стили не очень хорошо, поэтому поменяем строки местами:
    <link rel="stylesheet" href="css/app.css">	
	  <link rel="stylesheet" href="css/foundation.min.css">

А файл foundation.css удалим для экономии места. */

/* Обёртками для классов row и column/columns не обязательно должны быть дивы, могут быть хоть <p>, хоть <ul>, хоть <html5> - главное, чтобы они были блочными либо изначально, либо перебиты стилями на блочные. */

/* padding по высоте расчитывается от ширины контентной области, поэтому при padding: 50%; div автоматически становится квадратным */

/* чтобы не появлялся горизонтальный скролл на респонсив, прописываем
html, body {
	width: 100%;
	overflow-x: hidden;
}
но не помогло, скролл-то убрали, а "люфт" вправо-влево остался - почему?
 */

/* Элементы в ряду имеют свойство float left. Последний элемент в "незаконченном ряду" получает свойство float right. Чтобы отменить такое поведение последнего элемента, последнему блоку column дописывают класс end. */

/* Чтобы избавиться от паддингов между элементами, в родителе (row) делают запись medium-collapse <div class="row medium-collapse">. Чтобы вернуть паддинги в большем разрешении, добавляют large-uncollapse

<div class="row medium-collapse large-uncollapse"> */

/* По умолчанию, контентная область имеет какую-то максимальную ширину (1200px, к примеру). Если мы хотим растянуть элементы на всю ширину экрана, мы дописываем  expanded в row. expanded убивает паддинги по краям блока, чем нарушает сетку */

/* medium-offset-1, записанное в класс блока, смещает блок на одну колонку. Офсеты всегда добавляются к блоку с левой стороны (потому что блоки флоатятся влево), не бывает правых офсетов. Блок при этом сохраняет свою ширину (medium-12), но сдвигается марджином вправо на ширину одной колонки (medium-offset-1). */

/* class="column row" применяют для сокращения кода, чтобы не писать вложенные колонки (column) в строке (row), если требуется написать блок в одну строку на ширину всего контента, с такими же паддингами по краям, как у всех остальных блоков сетки. */

/* Вложенные колонки позволяют реализовать иную сетку внутри сайта со стандатрной сеткой. */

/* Есть возможность указать классы, которые показывают, сколько элементов мы хотим иметь в строке - 3, 4, 10... - не вычисляя никаких расстояний (small-up-1 medium-up-2 large-up-3 col-pallete).

<div class="medium-8 column show-for-large"> - show-for-large означает, что контент будет показан только при разрешении экрана от 1024 (large работает от 1024) и выше. А меньше - будет скрываться. Диву проставляется display: none;, но место под див не пропадает, вёрстка не сдвигается. show-for-medium - элемент исчезнет на small. show-for-small не имеет смысла, т.к. был бы показан всегда.

подобные классы:
.show-for-medium
.show-for-medium-only - странное поведение
.hide-for-medium - странное поведение
.hide-for-medium-only - на medium элемент исчезает, блоки остаются на своих местах

.hide - элемент исчезает, блоки смещаются

.invisible - элемент исчезает, место под блок остаётся на своём месте
*/

/* Блочная сетка - быстрый способ создать столбцы одинакового размера. Добавьте класс  .[size]-up-[n], чтобы изменить число столбцов в пределах ряда. По умолчанию, максимальное число столбцов, которые можно использовать с блоком в сетке - 8. Если добавить класс .column-block для columns, то появится bottom margin, равный вертикальному отступу по ширине.

<div class="row small-up-2 medium-up-3 large-up-4">

	<div class="column column-block">
		<img src="#" alt="1">
	</div>
	
	<div class="column column-block">
		<img src="#" alt="2">
	</div>
	
	<div class="column column-block">
		<img src="#" alt="3">
	</div>
	
	<div class="column column-block">
		<img src="#" alt="4">
	</div>
	
</div>
*/

/* visibility classes */
/* чтобы скрыть элемент, можно не писать display: none;, а использовать готовые классы. Есть два варианта, первый - выставить класс show-for-large/medium:

<div class="row">
	<div class="column-12 show-for-large"></div>
</div>

второй - выставить класс hide-for-medium-only;
<div class="row">
	<div class="column small-12 hide-for-medium-only"></div>
</div>
*/

/* классы .float-left; .float-right;
(класс .clearfix ставится на родителя, класс row имеет .clearfix по умолчанию);
работают внутри колонки
*/

/* .float-center = margin: 0 auto; */

/* дриллдаун меню, off-canvas, ?tobblers?, pagination, аккордеон (разворачивающиеся/сворачивающиеся блоки), helper classes для работы с текстом, <ul class="no-bullet">
*/

/* source ordering используется для вертикального перестроения блоков. (РАЗОБРАТЬСЯ ДЕТАЛЬНО, В ДОКАХ ЕСТЬ ДРУГИЕ ПРИМЕРЫ)

Для начала, работа классов без изменения разрешения.
При применении класса с pull, блок в строке смещается влево (на абсолюте?) на столько колонок, сколько указано в классе pull. (pull-4 - на 4 колонки влево). Аналогично, классы с push смещают блок в строке вправо (на абсолюте?) на столько колонок, сколько указано в классе push. (push-4 - на 4 колонки вправо).

					В строке
					Push - смещает вправо
					Pull - смещает влево

Когда на мобильных устройствах, к примеру, удобно картинку иметь cверху, а меню расположить под картинкой, то на большом экране картинку и меню удобно расположить в одну строку, картинку, к примеру справа, а меню - слева. Чтобы первый блок в строке (в нашем примере - меню), при перестроении под моб.устройство, повел себя нестандартно и ушёл во второй блок, а картинка при перестроении  под моб.устройство не стала бы вторым блоком, но первым, используют классы push и pull, которые действуют только на бОльших разрешениях и меняют очерёдность колонок на абсолюте. Действие этих классов отменяется при меньшем расширении, и блоки стандартно перестраиваются один под другим.
					
<div class="row">
  <div class="small-10 small-push-2 columns">10</div>
  <div class="small-2 small-pull-10 columns">2, last</div>
</div>
Просто поменяли строки местами, перестроение не происходит, поскольку мобайл-фёрст, задан класс small, правило работает для всех классов.


<div class="row">
  <div class="large-9 large-push-3 columns">9</div> - первый блок
  <div class="large-3 large-pull-9 columns">3, last</div> - второй блок
</div>
Брейкпоинт на 1024. Поскольку small и medium не заданы, то Уже брейкпоинта, классы large-push-3 и large-pull-9 ужЕ не работают, блоки перестроятся один под другой. large-9 пойдёт первой строкой, large-3 пойдёт второй строкой. Оба блока станут шириной в 12 колонок.

<div class="row">
  <div class="small-5 small-push-7 medium-7 medium-push-5 red columns">s5 m7</div>
  <div class="small-7 small-pull-5 medium-5 medium-pull-7 grey columns">s7 m5, last</div>
</div>
Задан класс small - вертикального перестроения не будет. При увеличении разрешения экрана на брейкпоинте 640 класс medium поменяет пропорции блоков с пяти колонок на семь, и с семи колонок на пять. Класс medium передаст свои свойства классу large, на 1024+ ничего не изменится.


<div class="row">
  <div class="medium-6 medium-push-6 columns">6</div>
  <div class="medium-6 medium-pull-6 columns">6, last</div>
</div>
Колонки равны по ширине. Брейкпоинт на 640, шире брейкпоинта второй блок идёт первым в строке, уже брейкпоинта - второй блок перестраивается под первый
*/



































































