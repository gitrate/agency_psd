/* ******************************************
27_lesson_css_13
медиа-запросы / media query */

/* медиа-запрос
записывают в CSS-файле, запись начинается с @media (без пробелов), эта запись указывает на то, что сейчас пойдёт тело запроса */

/* тип носителя
дальше, через пробел указывается тип носителя - всего их четыре вида, и ноль или более характеристик носителя

			media types

	all				все устройства
	
	print			для постраничного просмотра материала и документов, просматриваемых на
						экране в режиме предварительного просмотра перед печатью.
						
	screen		компьютеры, телефоны и т.п.
	
	speech		устройства для синтеза речи
  */

	/* логические операторы
	обычно используют всего два ("and" - "и", "или" - ","(запятая)) из четырёх (и, или, только, не) ("только" - "only" (нет смысла выделять какое-то конкретное устройство, обычно указывают media types -  screen, и этого достаточно), "не" - "not")
	*/
	
/* характеристики медиа-запроса
(ширина, высота, aspect-ratio - (16:9, 16:10, 3:4), orientation - portrait, landscape, плотность набивки пикселей, монохромные устройства ... ). Основной характеристикой является ширина, поскольку редко когда требуется ограничение по высоте устройства, ограничивая ширину, мы "выдавливаем" контент вниз:

@media screen and (min-width: 640px) and (max-width: 1024px)

если с характеристиками медиа-запроса разобрались, то открываем фигурные скобки,
пишем, как в CSS, селектор, к которому хотим применить правило

@media screen and (min-width: 640px) and (max-width: 1024px) {
	 h1 {
		 font-size: 18px;
	 }
	 .sidebar {
		 background: #dadada;
	 }
}
*/

/* Принцип mobile-first подразумевает, что мобильному устройству нужно как можно быстрее отрендерить страницу, а для этого качать как можно меньше CSS-правил. Обычно записывается стандартный CSS, а ниже идут медиа-запросы, которые меняют поведение элементов, указанных в медиа-запросе на той ширине (диапазоне), которая указана в медиа-запросе (для бОльших мониторов, на быстрых каналах связи). При такой записи, мобильное устройство не будет трогать/видеть медиа-запрос (но файл-то всё равно скачает полностью)
Медиа-запросы в обычных случаях обладают более высоким приоритетом. Поскольку подчиняются стандартной каскадности, именно из-за этого медиа-запросы записываются внизу CSS-файла, чтобы они могли перебить наши основные стили. Медиа-запросы с max-width перебивают друг друга, если записаны от меньшего размера к большему, с min-width картина обратная - сначала пишут правила для наибольших размеров, а потом идут правила со всё меньшими размерами экрана.
Если дизайн не мобайл-фёрст, то при уменьшении размера экрана мы ловим момент, когда вёрстка начинает ломаться и пишем для этого разрешения медиа-запрос.
При выборе подхода к вёрстке, необходимо стремиться к уменьшению количества правил и медиа-запросов, чтобы ускорить загрузку.
На андроидах - хромах и мозиллах - там, обычно, всё в порядке. В мобильных сафари, обычно, те же грабли, что и в десктопных сафари. Проверять респонсив на сафари лучше на самих девайсах, т.к., процентов 50 того, что вылезет на устройстве, эмулятор не отловит. Эксплореров на моб.устр. нет, но есть Эдж, который более-менее ОК.
Мастхэв - проверка в хроме и мозилле (отличия в vertical-align - в хроме все строчные элементы пытаются стать по-центру, а в мозилле - по-верху), поэтому в ресетах нужно всем строчным и строчно-блочным элементам вести себя одинаково, vertical-align: middle, например.
*/

/*
*********************************************************************************
Остановка на тайминге 0:23:00
*********************************************************************************
*/


/* ******************************************
28_lesson_css_14
FOUNDATION (база, основа)
*/

/* выбор ширины контентной области */

/*
стандартный отступ между колонками - 
15px + 15px = 30px; по краям - 15px.
*/

/*
Необходимо взвешенно подходить к выбору, использовать фреймворк или нет, а если использовать, то грузить только необходимые компоненты.
100% : 12 колонок = 8,33% - ширина одной колонки при  стандартной верстке в 12 колонок.
*/

/* диапазон ширины экрана, в которых работают классы:

class="small" - 639px и меньше
class="medium" - от 640px до 1023px
class="large" - от 1024px и до бесконечности
*/

/* принцип mobile first - 
задаётся класс small, и если его не "остановить", то при увеличении экрана (при выходе за границы действия класса small - 639px) количество колонок, заданных классом small, будет сохраняться до бесконечности;
класс medium "перебивает" действие класса small и может установить своё кол-во колонок в диапазоне от 640px до 1023px/(или до бесконечности, если класс medium не перебит классом large);
класс large "перебивает" действие классов medium и small и может установить своё кол-во колонок в диапазоне от 1024px и до бесконечности.
*/

/* <div class="row"> <!-- row - ряд - обязательный контейнер для колонок column/columns (column = columns) -->
	<div class="small-1 column"></div> <!-- одна колонка во всех диапазонах, обязательно указывать класс column -->
</div>

<div class="row">
	<div class="small-1 medium-2 column"></div> <!-- одна колонка до 639px и две от 640px до бесконечности -->
</div>

<div class="row">
	<div class="small-1 medium-2 large-4 column"></div> <!-- одна колонка до 639px, две от 640px до 1023px и четыре колонки от 1024px до бесконечности -->
</div>
*/

/* Если в html-коде foundation в файле html задать класс medium и не указать класс small, то при уменьшении ширины экрана менее 640px, все блоки станут один под другим и станут как small-12 (на всю ширину экрана)
Чтобы избежать такого поведения блоков при уменьшении экрана и оставить поведение блоков таким же как в medium, нужно дописать в блоках классы small с теми же параметрами, что у medium.
А это значит, что если мы не хотим, чтобы поведение блоков менялось при любой ширине экрана, нам достаточно задавать только класс small. 
*/

/* Нам никто не запрещает писать свои медиа-запросы. К примеру, мы хотим получить определённое поведение элементов страницы на разрешении от 1200px до 1500px - пишем:

@media screen and (min-width: 1200px) and (max-width: 1500px) {
	 h1 {
		 font-size: 18px;
	 }
	 .sidebar {
		 background: #dadada;
	 }
}
*/

/* Можно использовать правило флоатов, которому подчиняются колонки в фреймворке, и написать, к примеру, small-6, small-6, small-12; small-12 перенесётся на новую строку. */

/* foundation.zurb.com */

/* Все размеры считаются в REM'ах. Total gutter = 1,875rem; 1,875 * 16 = 30px - общее расстояние между двух колонок. По обеим сторонам колонки имеем padding 30px/2 = 15px */

/* max-width = 62,5rem = 62,5 * 16 = 1000px - ширина контентной части по умолчанию
1000/16 = max-width 62,5 rem
16px - к примеру, высота шрифта по умолчанию */

/* Настройки по-умолчанию можно менять под свои нужды. */

/* Essential - облегчённый вариант без JS-элементов, которые написаны на jQuery */

/* app.css - сюда пишут свои стили;
foundation.min.css - сжатые стили фреймворка, которые нужны для работы приложения, весит меньше, чем foundation.css;
foundation.css - классически отформатированный файл стилей, который позволяет кодерам покопаться в коде, понять, что и как работает, для сайта не нужен. */

/* После скачивания Foundation, мы имеем две папки - css и img, и файл index.html в корне проекта.

В index.html в header мы видим строки

    <link rel="stylesheet" href="css/foundation.css">
    <link rel="stylesheet" href="css/app.css">
	Логика такого расположения в том, чтобы кастомные стили перебили стандартный стиль foundation, перебивать стандартные стили не очень хорошо, поэтому поменяем строки местами:
    <link rel="stylesheet" href="css/app.css">	
	  <link rel="stylesheet" href="css/foundation.min.css">

А файл foundation.css удалим для экономии места. */

/* Обёртками для классов row и column/columns не обязательно должны быть дивы, могут быть хоть <p>, хоть <ul>, хоть <html5> - главное, чтобы они были блочными либо изначально, либо перебиты стилями на блочные. */

/* padding по высоте расчитывается от ширины контентной области, поэтому при padding: 50%; div автоматически становится квадратным */

/* чтобы не появлялся горизонтальный скролл на респонсив, прописываем
html, body {
	width: 100%;
	overflow-x: hidden;
}
но не помогло, скролл-то убрали, а "люфт" вправо-влево остался - почему?
 */

/* Элементы в ряду имеют свойство float left. Последний элемент в "незаконченном ряду" получает свойство float right. Чтобы отменить такое поведение последнего элемента, последнему блоку column дописывают класс end. */

/* Чтобы избавиться от паддингов между элементами, в родителе (row) делают запись medium-collapse <div class="row medium-collapse">. Чтобы вернуть паддинги в большем разрешении, добавляют large-uncollapse

<div class="row medium-collapse large-uncollapse"> */

/* По умолчанию, контентная область имеет какую-то максимальную ширину (1200px, к примеру). Если мы хотим растянуть элементы на всю ширину экрана, мы дописываем  expanded в row. expanded убивает паддинги по краям блока, чем нарушает сетку */

/* medium-offset-1, записанное в класс блока, смещает блок на одну колонку. Офсеты всегда добавляются к блоку с левой стороны (потому что блоки флоатятся влево), не бывает правых офсетов. Блок при этом сохраняет свою ширину (medium-12), но сдвигается марджином вправо на ширину одной колонки (medium-offset-1). */

/* class="column row" применяют для сокращения кода, чтобы не писать вложенные колонки (column) в строке (row), если требуется написать блок в одну строку на ширину всего контента, с такими же паддингами по краям, как у всех остальных блоков сетки. */

/* Вложенные колонки позволяют реализовать иную сетку внутри сайта со стандатрной сеткой. */

/* Есть возможность указать классы, которые показывают, сколько элементов мы хотим иметь в строке - 3, 4, 10... - не вычисляя никаких расстояний (small-up-1 medium-up-2 large-up-3 col-pallete).

<div class="medium-8 column show-for-large"> - show-for-large означает, что контент будет показан только при разрешении экрана от 1024 (large работает от 1024) и выше. А меньше - будет скрываться. Диву проставляется display: none;, но место под див не пропадает, вёрстка не сдвигается. show-for-medium - элемент исчезнет на small. show-for-small не имеет смысла, т.к. был бы показан всегда.

подобные классы:
.show-for-medium
.show-for-medium-only - странное поведение
.hide-for-medium - странное поведение
.hide-for-medium-only - на medium элемент исчезает, блоки остаются на своих местах

.hide - элемент исчезает, блоки смещаются

.invisible - элемент исчезает, место под блок остаётся на своём месте
*/

/* Блочная сетка - быстрый способ создать столбцы одинакового размера. Добавьте класс  .[size]-up-[n], чтобы изменить число столбцов в пределах ряда. По умолчанию, максимальное число столбцов, которые можно использовать с блоком в сетке - 8. Если добавить класс .column-block для columns, то появится bottom margin, равный вертикальному отступу по ширине.

<div class="row small-up-2 medium-up-3 large-up-4">

	<div class="column column-block">
		<img src="#" alt="1">
	</div>
	
	<div class="column column-block">
		<img src="#" alt="2">
	</div>
	
	<div class="column column-block">
		<img src="#" alt="3">
	</div>
	
	<div class="column column-block">
		<img src="#" alt="4">
	</div>
	
</div>
*/

/* visibility classes */
/* чтобы скрыть элемент, можно не писать display: none;, а использовать готовые классы. Есть два варианта, первый - выставить класс show-for-large/medium:

<div class="row">
	<div class="column-12 show-for-large"></div>
</div>

второй - выставить класс hide-for-medium-only;
<div class="row">
	<div class="column small-12 hide-for-medium-only"></div>
</div>
*/

/* классы .float-left; .float-right;
(класс .clearfix ставится на родителя, класс row имеет .clearfix по умолчанию);
работают внутри колонки
*/

/* .float-center = margin: 0 auto; */

/* дриллдаун меню, off-canvas, ?tobblers?, pagination, аккордеон (разворачивающиеся/сворачивающиеся блоки), helper classes для работы с текстом, <ul class="no-bullet">
*/

/* source ordering используется для вертикального перестроения блоков. (РАЗОБРАТЬСЯ ДЕТАЛЬНО, В ДОКАХ ЕСТЬ ДРУГИЕ ПРИМЕРЫ)

Для начала, работа классов без изменения разрешения.
При применении класса с pull, блок в строке смещается влево (на абсолюте?) на столько колонок, сколько указано в классе pull. (pull-4 - на 4 колонки влево). Аналогично, классы с push смещают блок в строке вправо (на абсолюте?) на столько колонок, сколько указано в классе push. (push-4 - на 4 колонки вправо).

					В строке
					Push - смещает вправо
					Pull - смещает влево

Когда на мобильных устройствах, к примеру, удобно картинку иметь cверху, а меню расположить под картинкой, то на большом экране картинку и меню удобно расположить в одну строку, картинку, к примеру справа, а меню - слева. Чтобы первый блок в строке (в нашем примере - меню), при перестроении под моб.устройство, повел себя нестандартно и ушёл во второй блок, а картинка при перестроении  под моб.устройство не стала бы вторым блоком, но первым, используют классы push и pull, которые действуют только на бОльших разрешениях и меняют очерёдность колонок на абсолюте. Действие этих классов отменяется при меньшем расширении, и блоки стандартно выстраиваются один под другим.
					
<div class="row">
  <div class="small-10 small-push-2 columns">10</div>
  <div class="small-2 small-pull-10 columns">2, last</div>
</div>
Просто поменяли строки местами, перестроение не происходит, поскольку мобайл-фёрст, задан класс small, правило работает для всех классов.


<div class="row">
  <div class="large-9 large-push-3 columns">9</div> - первый блок
  <div class="large-3 large-pull-9 columns">3, last</div> - второй блок
</div>
Брейкпоинт на 1024. Поскольку small и medium не заданы, то Уже брейкпоинта, классы large-push-3 и large-pull-9 ужЕ не работают, блоки перестроятся один под другой. large-9 пойдёт первой строкой, large-3 пойдёт второй строкой. Оба блока станут шириной в 12 колонок.

<div class="row">
  <div class="small-5 small-push-7 medium-7 medium-push-5 red columns">s5 m7</div>
  <div class="small-7 small-pull-5 medium-5 medium-pull-7 grey columns">s7 m5, last</div>
</div>
Задан класс small - вертикального перестроения не будет. При увеличении разрешения экрана на брейкпоинте 640 класс medium поменяет пропорции блоков с пяти колонок на семь, и с семи колонок на пять. Класс medium передаст свои свойства классу large, на 1024+ ничего не изменится.


<div class="row">
  <div class="medium-6 medium-push-6 columns">6</div>
  <div class="medium-6 medium-pull-6 columns">6, last</div>
</div>
Колонки равны по ширине. Брейкпоинт на 640, шире брейкпоинта второй блок идёт первым в строке, уже брейкпоинта - второй блок перестраивается под первый
*/

/* ******************************************
29_lesson_css_15 - agency_psd */

/* WebStorm - Ctrl + Alt + L -
отформатировать код в редакторе;
найти горячие клавиши WebStorm, найти клавиатурные сокращения Emmet;
Photoshop - Ctrl + H - скрыть сетку */

Открываем PSD и смотрим, сетка или не сетка, какой размер контентной области, настраиваем сетку. Смотрятся самые основные элементы - списки, ссылки, параграфы, заголовки, запихиваем их в ресет. По максимуму описываем то, что можно. Дальше пошли по элементам (детализация). 01:14:30 - как правильно забирать картинки.


/* 1. Смотрим, какие используются шрифты, смотрим на обычный текст, заголовки и т.д. Устанавливаем недостающие шрифты в Win для Photoshop. (оставлять ли шрифты в проекте?) Установка шрифтов в винде - два способа:
а) Выделить закачанные шрифты > ПКМ >  Install;
б) Или закинуть шрифты руками в Fonts: Control Panel > Appearance and Personalization > Fonts. После установки шрифтов, необходимо перезагрузить шаблон Photoshop, чтобы Photoshop подхватил шрифты.

2. Смотрим цвета.
3. Смотрим кнопки.
4. Разбираемся с заголовками.

Первым делом в CSS заносим ресеты:

html, body {
	  font-family: 'Montserrat', sans-serif; - подключаем шрифты
    overflow-x: hidden; - запрещаем горизонтальный скролл
    width: 100%; - убираем отступы браузера по умолчанию
}
25:16, 27:10 - app.css
02:01:20 - index.html

задаём правила для параграфа
p {
    color: #0d113d; - цвет шрифта
    font: 300(font weight)  (font-size)15px/26px(line-height)  (font-family)'Montserrat', sans-serif;
    margin: 0; - убираем отступы снизу по умолчанию
}
(line-height 26px только у параграфа, у остальных элементов делаем относительный line-height 1)

задавать line-height в отношениях лучше - гибче, если меняется font-size, автоматически меняется line-height. Но, поскольку в шаблоне заданы пиксели, то можем не попасть, вписываем в line-height пиксели.

<div class="border">
	
</div>

.border { - зададим этот класс > h3
	position: relative;
	padding-left: 19px; - абсолютные элементы (border:before) устанавливаются по паддингу
}
.border:before {
	content: '';
	position: absolute;
	left: 0;
	top: 0;
	height: 100%;
	width: 5px;	
	border-radius: 5px;
}

ресетим ещё:
У списков ul? отменяем margin, даём font-size; убираем буллеты у li; li делаем display: inline-block; h1, h2, h3, h4 - убираем margin, line-height = 1, (text-transform: uppercase); ссылки - цвет, стиль, транзишн, и ховер/эктив a:hover, a:active {color: #} (только цвет).

В ховере прописываем, что мы будем транзитить.
А на самом элементе прописываем transition. Плавный переход в оранжевый (чего?) - transition(1. что мы будем транзитить(color), 2. по какой функции(ize-in-out?) (время перехода)0.2 сек)

Логотип оборачивают в ссылку <a href="корень сайта"><img src="" alt=""/></a>

текст в кнопках выровнен от левого края 69px, но лучше по-центру, не располагать в сетке, поскольку кнопки, обычно, имеют постоянный размер, внутри кнопок падидинги, чтобы текст никогда не влипал в края кнопки, кнопки центрировать/выравнивать либо на паддингах, либо делать их флекс-элементами; несколько видов бордеров и текста (цвет), 

h4 (иконки с текстом), h2 - Great Support System, h3 - SERVICES, PORTFOLIO, BLOG.

ВЁРСТКА

Хэдер имеет общий бэкграунд с первым блоком, значит впихиваем это всё в общий блок top-section, внутрь кладём хэдер, который будет row, чтобы он подчинялся сетке. Бэкграунд даём обёртке. Всё, что приаттачено к сетке - заворачиваем в row. row сам по себе не используется, внутри должен лежать small/medium/large column, иначе мы не попадём в сетку. Начинаем верстать с large.

<div class="top-section"> - тут ляжет бэкграунд
	<header class="row">
		<div class="small-x column">
			<a href="#">bl<img src="" alt="">m</a>
		<nav class="small-x column">
			<ul>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
			</ul>
		</nav>
		</div>
	</div>
</div>

кнопки идут с небольшими паддингами и min-width
.text-center, medium-text-center - выравниваем текст внутри кнопок
small-centered large-uncentered - выравниваем кнопки в неполных column
<div class="row>
	<div class="small-3 small-centered column">
		3 centered
	</div>
</div>

линия - border-bottom; у внешней обёртки должны быть паддинги, потому что марджины отталкивают только внешние элементы

Если вёрстка разваливается, смотрится некрасиво, то повышаем класс (со small, к примеру, до medium, с medium до large)

Под картинкой можно флоатами, инлайн-блоками или флексами - чтобы не уменьшать кнопку

КАК ДОСТАТЬ КАРТИНКУ.
Картинка лежит в слое. Стрелочка вниз означает, что слой ссылается на шейп ниже. Шейп - это контур. Инструмент Path Selection Toll (кнопка "a")  или Moov Tool, выделяем слой (Layer) и связанные слои со стрелочками - конверт ту смарт обджект, выделяем полученный смарт обджект - Ctrl + ЛКМ на иконке шейпа, получили выделенный участок, нажимаем внизу Add layer mask (забираем из сетки контур), в слое появилась иконка маски - теперь конверт ту смарт обджект, двойной щелчёк на иконке Layer'а, получили требуемое изображение.

/* ******************************************
33_lesson_css_16
Agency template, part 2
*/

/* Градиент
в CSS применяется к четырём свойствам:
background
background-image
border-image
list-style-image
градиент бывает линейным и радиальным
*/
/* пример кода
статья - https://html5book.ru/css3-gradient/

В 100% случаев, градиент вешают на блок на абсолюте, в background, потому что в бордерах это работает только в хроме, на моб. устройствах - на бордерах вообще не работает

пример кода:
div {
height: 200px;
background: linear-gradient(to top, #E4AF9D 20%, #E4E4D8 50%, #A19887 80%);
}
*/

колорзилла выдала градиент для SERVICES:
background: linear-gradient(to bottom, rgba(117,61,157,0) 0%,rgba(117,61,157,0.6) 100%);

Кладём весь SERVICES-блок в один row. Верхняя половинка large-3 4 элемента, нижня - large-7 и large-5

Чтобы скопировать картинки без закруглений, выделяем картинку, как описано в предыдущей лекции, прикладываем направляющие по четырём сторонам картинки, берём инструмент Rectangle Tool и от выделяем по диагонали. Выбираем прозрачный фон и бордер и перетаскиваем слой под картинку - получили в итоге в новом слое ниже картинки прямоугольный шейп. Далее - по старому алгоритму. 

А радиус скругления потом даём блоку (не картинке) и укажем overflow: hidden; Радиус закругления определяем при помощи Rectangle Tool с Shift'ом.


/* ******************************************
34_lesson_css_17 - Agency, судный день.
*/

SERVICES-блок
картинки имеют два наложения - градиент, который положен через after-элемент - в small вкладываем ещё один div, чтобы градиент не залазил в padding, как-то называем его. В этот див входит картинка, и два псевдоэлемента before и after. На before кладём background на абсолюте. Градиент на after. 
<div class="block_name">
	::before
	<img src="#" alt=""/>
</div>
.block_name::before {
	background-color: rgba(25, 11, 35, 0.6);
	content: "";
	position: absolute;
	top: opx;
	left: 0px;
	height: 100%;
	width: 100%;
}
Объяснение до  0:24:

0:24:21 - app.js

0:24:29 - index.html

с 00: 33:45v по 00:41:20 персональное объяснение Emmet

01:29:50 - как поставить точки на li

01:47:00 - SERVICES-блок, анимация
текст с заголовком и т.п. лежит на 300px от top. У этого блока должен быть overflow: hidden; А по hover делаем ему top 135px. чтобы он сделал это плавно, надо выставить на тот элемент, которому указываем top, transition. НА СЛУХ: Transition top (?easy-in-out?) (время исполнения ) 
кроме того, дописываем по hover изменения в after - теперь он занимает height:100%,  а background (background: linear-gradient(to bottom, rgba(117,61,157,0) 0%,rgba(117,61,157,0.6) 100%);) не linear-gradient, а тот, который здесь у него указан (где?, в PS?). И анимируем два свойства, хотя для простоты можно написать all - все свойства, которые лежат под ховером. Ховер написан к обёртке, в которой лежит картинка, назовём этот div servise-holder. Servise-holder у нас relative, overflowed, на нём border-radius - это уже есть. Теперь говорим, что когда servise-holder в hover'е, ему сразу пишется after, открываем скобку и прописываем height: 100%; новый background - это произойдёт действие. Чтобы действие произошло анимированно, мы сначала должны обратиться к after'у - servise-holder:after и написать ему transition. То же самое сделать с блоком, в котором у нас лежит текст (article-holder, назовём так). Обращаемся к article-holder, тоже пишем ему transition (у него только top будет транзититься). И дальше от servise-holder по hover'у обращаемся к article-holder - НА СЛУХ: servise-holder:hover .article-holder {top: 135px;}. Обёрткам, которые мы назвали servise-holder, надо задать высоту, чтобы она у всех была одинаковая, иначе будут проблемы и с float'ами, и с ?"выезжалками"? - если картинка будет меньше, у нас ?ЭТОТ? блок будет меньше, выезжать будет по-разному - 340px.

Стрелка может быть на абсолюте. Или же делаем текст ссылкой, а стрелку в бэкграунде.
